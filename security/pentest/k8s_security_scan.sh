#!/bin/bash

# =======================================================================
# MLSecOps - Script de Verificação de Segurança do Kubernetes
# Autor: Luana Gonçalves
# Data: 13/05/2025
# Descrição: Verifica vulnerabilidades e configurações inseguras no cluster
# =======================================================================

set -e
BLUE='\033[0;34m'
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # Sem cor

# Gerar nome do relatório com timestamp
REPORT_FILE="security_report_$(date +%Y%m%d_%H%M%S).txt"
TOTAL_ISSUES=0
CRITICAL_ISSUES=0
HIGH_ISSUES=0

echo "=====================================================
MLSecOps - Relatório de Segurança Kubernetes
Data: $(date)
Cluster: $(kubectl config current-context)
=====================================================" > $REPORT_FILE

# Função para adicionar resultados ao relatório
add_to_report() {
    local title=$1
    local severity=$2
    local message=$3
    local recommendations=$4
    local regex=$5
    local count=0
    
    if [[ ! -z "$regex" && ! -z "$message" ]]; then
        count=$(echo "$message" | grep -E "$regex" | wc -l)
    elif [[ ! -z "$message" ]]; then
        count=$(echo "$message" | wc -l)
    fi
    
    if [[ $count -gt 0 ]]; then
        echo -e "\n--------------------------------------------------" >> $REPORT_FILE
        echo "PROBLEMA: $title" >> $REPORT_FILE
        echo "SEVERIDADE: $severity" >> $REPORT_FILE
        echo "CONTAGEM: $count ocorrência(s)" >> $REPORT_FILE
        echo -e "\nDETALHES:" >> $REPORT_FILE
        echo "$message" >> $REPORT_FILE
        echo -e "\nRECOMENDAÇÕES:" >> $REPORT_FILE
        echo "$recommendations" >> $REPORT_FILE
        echo "--------------------------------------------------" >> $REPORT_FILE
        
        TOTAL_ISSUES=$((TOTAL_ISSUES + 1))
        if [[ "$severity" == "CRÍTICO" ]]; then
            CRITICAL_ISSUES=$((CRITICAL_ISSUES + 1))
        elif [[ "$severity" == "ALTO" ]]; then
            HIGH_ISSUES=$((HIGH_ISSUES + 1))
        fi
        
        return 0
    else
        return 1
    fi
}

echo -e "${BLUE}Iniciando verificações de segurança do Kubernetes...${NC}"

# 1. Verificar Pods com privilégios elevados
echo -e "${BLUE}Verificando Pods com privilégios elevados...${NC}"
PRIVILEGED_PODS=$(kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{range .spec.containers[*]}{"\t"}{.securityContext.privileged}{end}{end}' | grep -E "true" || echo "")
if add_to_report "Containers com privilégios elevados" "CRÍTICO" "$PRIVILEGED_PODS" "Remova a configuração securityContext.privileged=true dos containers. Utilize o princípio de privilégio mínimo."; then
    echo -e "${RED}✗ Encontrados containers com privilégios elevados${NC}"
else
    echo -e "${GREEN}✓ Nenhum container com privilégios elevados encontrado${NC}"
fi

# 2. Verificar Secrets não criptografados
echo -e "${BLUE}Verificando Secrets não criptografados...${NC}"
UNENCRYPTED_SECRETS=$(kubectl get secrets --all-namespaces -o json | jq -r '.items[] | select(.type=="Opaque") | .metadata.namespace + " " + .metadata.name' | xargs -I {} echo "Secret: {}" || echo "")
if add_to_report "Secrets potencialmente não criptografados" "ALTO" "$UNENCRYPTED_SECRETS" "Considere utilizar soluções como Vault, Google KMS ou Sealed Secrets para criptografar seus segredos."; then
    echo -e "${YELLOW}✗ Secrets potencialmente inseguros encontrados${NC}"
else
    echo -e "${GREEN}✓ Nenhum problema com Secrets encontrado${NC}"
fi

# 3. Verificar Pods sem limites de recursos
echo -e "${BLUE}Verificando Pods sem limites de recursos...${NC}"
PODS_WITHOUT_LIMITS=$(kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{range .spec.containers[*]}{"\t"}{"Limites: "}{.resources.limits}{end}{end}' | grep -E "Limites: null|Limites: <no value>|Limites: $" || echo "")
if add_to_report "Containers sem limites de recursos definidos" "ALTO" "$PODS_WITHOUT_LIMITS" "Configure limits.cpu e limits.memory para todos os containers para prevenir ataques de negação de serviço por consumo excessivo de recursos."; then
    echo -e "${YELLOW}✗ Encontrados containers sem limites de recursos${NC}"
else
    echo -e "${GREEN}✓ Todos os containers têm limites de recursos definidos${NC}"
fi

# 4. Verificar serviços expostos externamente
echo -e "${BLUE}Verificando serviços expostos externamente...${NC}"
EXPOSED_SERVICES=$(kubectl get svc --all-namespaces -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{"\t"}{.spec.type}{end}' | grep -E "LoadBalancer|NodePort" || echo "")
if add_to_report "Serviços expostos externamente" "MÉDIO" "$EXPOSED_SERVICES" "Avalie se estes serviços realmente precisam ser expostos externamente. Considere usar um Ingress Controller ou API Gateway para centralizar o acesso."; then
    echo -e "${YELLOW}✗ Serviços expostos externamente encontrados${NC}"
else
    echo -e "${GREEN}✓ Nenhum serviço exposto externamente${NC}"
fi

# 5. Verificar Network Policies
echo -e "${BLUE}Verificando Network Policies...${NC}"
NAMESPACES=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}')
NAMESPACES_WITHOUT_NETPOL=""

for ns in $NAMESPACES; do
    if [[ "$ns" != "kube-system" && "$ns" != "kube-public" && "$ns" != "kube-node-lease" ]]; then
        NETPOL_COUNT=$(kubectl get networkpolicy -n $ns -o jsonpath='{.items[*].metadata.name}' 2>/dev/null | wc -w || echo "0")
        if [[ "$NETPOL_COUNT" -eq 0 ]]; then
            NAMESPACES_WITHOUT_NETPOL+="$ns "
        fi
    fi
done

if [[ ! -z "$NAMESPACES_WITHOUT_NETPOL" ]]; then
    NETPOL_MSG="Namespaces sem Network Policies: $NAMESPACES_WITHOUT_NETPOL"
    add_to_report "Ausência de Network Policies" "MÉDIO" "$NETPOL_MSG" "Implemente Network Policies para restringir a comunicação entre pods apenas ao necessário, seguindo o princípio de privilégio mínimo."
    echo -e "${YELLOW}✗ Namespaces sem Network Policies encontrados${NC}"
else
    echo -e "${GREEN}✓ Todos os namespaces aplicáveis têm Network Policies${NC}"
fi

# 6. Verificar Role Bindings amplos
echo -e "${BLUE}Verificando Role Bindings com permissões amplas...${NC}"
BROAD_BINDINGS=$(kubectl get clusterrolebinding -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.roleRef.name}{"\t"}{.subjects[*].name}{end}' | grep -E "cluster-admin" || echo "")
if add_to_report "Role Bindings com permissões administrativas amplas" "ALTO" "$BROAD_BINDINGS" "Restrinja os Role Bindings para cluster-admin apenas aos usuários que realmente necessitam. Crie roles mais granulares com base no princípio de privilégio mínimo."; then
    echo -e "${RED}✗ Role Bindings com permissões administrativas amplas encontrados${NC}"
else
    echo -e "${GREEN}✓ Nenhum Role Binding amplo encontrado${NC}"
fi

# 7. Verificar Container Registry
echo -e "${BLUE}Verificando imagens de containers...${NC}"
CONTAINER_IMAGES=$(kubectl get pods -A -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{"\t"}{range .spec.containers[*]}{.image}{" "}{end}{end}' || echo "")
UNOFFICIAL_IMAGES=$(echo "$CONTAINER_IMAGES" | grep -E -v "gcr.io|docker.io/[^/]+/|quay.io|k8s.gcr.io|registry.k8s.io|southamerica-east1-docker.pkg.dev/" || echo "")

if add_to_report "Imagens de fontes não oficiais" "MÉDIO" "$UNOFFICIAL_IMAGES" "Utilize apenas imagens de registries confiáveis. Considere implementar uma solução de escaneamento de vulnerabilidades como Trivy para verificar as imagens antes da implantação."; then
    echo -e "${YELLOW}✗ Imagens de fontes potencialmente não confiáveis encontradas${NC}"
else
    echo -e "${GREEN}✓ Todas as imagens são de fontes oficiais${NC}"
fi

# 8. Verificar verificações de saúde (liveness/readiness probes)
echo -e "${BLUE}Verificando pods sem health checks...${NC}"
PODS_WITHOUT_PROBES=$(kubectl get pods -A -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{range .spec.containers[*]}{"\t"}{.name}{"\t"}{"livenessProbe: "}{.livenessProbe}{"\t"}{"readinessProbe: "}{.readinessProbe}{end}{end}' | grep -E "(livenessProbe: null|livenessProbe: <no value>|livenessProbe: $).*(readinessProbe: null|readinessProbe: <no value>|readinessProbe: $)" || echo "")
if add_to_report "Containers sem health checks" "BAIXO" "$PODS_WITHOUT_PROBES" "Configure liveness e readiness probes para todos os containers para garantir que o Kubernetes possa detectar e recuperar de falhas."; then
    echo -e "${YELLOW}✗ Containers sem health checks encontrados${NC}"
else
    echo -e "${GREEN}✓ Todos os containers têm health checks configurados${NC}"
fi

# 9. Verificar buckets expostos públicamente
if command -v gsutil &> /dev/null; then
    echo -e "${BLUE}Verificando buckets de storage expostos publicamente...${NC}"
    BUCKETS_OUTPUT=$(gsutil ls -p $PROJECT_ID 2>/dev/null || echo "")
    
    if [[ ! -z "$BUCKETS_OUTPUT" ]]; then
        PUBLIC_BUCKETS=""
        for bucket in $BUCKETS_OUTPUT; do
            # Remover gs:// do início e / do final
            BUCKET_NAME=$(echo $bucket | sed 's/gs:\/\///' | sed 's/\/$//')
            
            # Verificar se o bucket é público
            ACL_OUTPUT=$(gsutil iam get $bucket 2>/dev/null || echo "")
            if echo "$ACL_OUTPUT" | grep -q "allUsers\|allAuthenticatedUsers"; then
                PUBLIC_BUCKETS+="$BUCKET_NAME (público) "
            fi
        done
        
        if [[ ! -z "$PUBLIC_BUCKETS" ]]; then
            add_to_report "Buckets de armazenamento expostos publicamente" "CRÍTICO" "$PUBLIC_BUCKETS" "Remova os acessos públicos dos buckets utilizando: gsutil iam ch -d allUsers:objectViewer gs://bucket-name"
            echo -e "${RED}✗ Buckets públicos encontrados${NC}"
        else
            echo -e "${GREEN}✓ Nenhum bucket público encontrado${NC}"
        fi
    else
        echo -e "${YELLOW}⚠ Não foi possível listar buckets. Verifique suas permissões.${NC}"
    fi
else
    echo -e "${YELLOW}⚠ gsutil não está instalado. Pulando verificação de buckets.${NC}"
fi

# 10. Verificar uso de ServiceAccounts padrão
echo -e "${BLUE}Verificando uso de ServiceAccounts padrão...${NC}"
DEFAULT_SAS=$(kubectl get pods -A -o jsonpath='{range .items[*]}{"\n"}{.metadata.name}{"\t"}{.metadata.namespace}{"\t"}{"ServiceAccount: "}{.spec.serviceAccountName}{end}' | grep -E "ServiceAccount: default" || echo "")
if add_to_report "Pods usando ServiceAccount padrão" "MÉDIO" "$DEFAULT_SAS" "Crie ServiceAccounts dedicados para cada workload com permissões mínimas necessárias em vez de usar o ServiceAccount padrão."; then
    echo -e "${YELLOW}✗ Pods usando ServiceAccount padrão encontrados${NC}"
else
    echo -e "${GREEN}✓ Nenhum pod usa o ServiceAccount padrão${NC}"
fi

# Resumo
echo -e "\n${BLUE}Resumo da verificação de segurança:${NC}"
echo -e "===========================================" >> $REPORT_FILE
echo "RESUMO DA VERIFICAÇÃO DE SEGURANÇA" >> $REPORT_FILE
echo -e "Total de problemas encontrados: ${TOTAL_ISSUES}" >> $REPORT_FILE
echo -e "Problemas críticos: ${CRITICAL_ISSUES}" >> $REPORT_FILE
echo -e "Problemas de alta severidade: ${HIGH_ISSUES}" >> $REPORT_FILE
echo -e "===========================================" >> $REPORT_FILE

echo -e "${BLUE}Total de problemas encontrados: ${NC}${TOTAL_ISSUES}"
echo -e "${RED}Problemas críticos: ${NC}${CRITICAL_ISSUES}"
echo -e "${YELLOW}Problemas de alta severidade: ${NC}${HIGH_ISSUES}"
echo -e "${BLUE}Relatório salvo em: ${NC}${REPORT_FILE}"

# Limites para aprovar ou reprovar o scan
if [[ $CRITICAL_ISSUES -gt 0 ]]; then
    echo -e "${RED}✗ Verificação de segurança falhou: Encontrados problemas críticos${NC}"
    echo -e "RESULTADO: FALHA - Problemas críticos encontrados" >> $REPORT_FILE
    exit 1
elif [[ $HIGH_ISSUES -gt 2 ]]; then
    echo -e "${RED}✗ Verificação de segurança falhou: Muitos problemas de alta severidade${NC}"
    echo -e "RESULTADO: FALHA - Muitos problemas de alta severidade" >> $REPORT_FILE
    exit 1
else
    echo -e "${GREEN}✓ Verificação de segurança passou com ${YELLOW}${TOTAL_ISSUES}${GREEN} problemas não críticos${NC}"
    echo -e "RESULTADO: PASSOU - Com advertências" >> $REPORT_FILE
    exit 0
fi